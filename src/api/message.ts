import axiosInstance from './base';
import { createMessageNotification, pushNotificationManager } from '../utils/pushNotifications';

// Types for API responses
export interface Message {
  _id: string;
  chatId: string;
  sender: {
    _id: string;
    username: string;
    fullName: string;
    profileImageUrl?: string;
  };
  message: string;
  messageType: 'text' | 'image' | 'video' | 'file' | 'audio' | 'location';
  mediaUrl?: string;
  fileName?: string;
  fileSize?: number;
  duration?: number;
  location?: {
    latitude: number;
    longitude: number;
    address: string;
  };
  replyTo?: string;
  timestamp: string;
  readBy: string[];
  isDeleted: boolean;
  deletedAt?: string;
  editedAt?: string;
  reactions: Array<{
    user: string;
    emoji: string;
    timestamp: string;
  }>;
}

export interface Chat {
  _id: string;
  participants: Array<{
    _id: string;
    username: string;
    fullName: string;
    profileImageUrl?: string;
  }>;
  chatType: 'direct' | 'group';
  groupName?: string;
  groupDescription?: string;
  groupImage?: string;
  admins?: string[];
  createdBy: {
    _id: string;
    username: string;
    fullName: string;
    profileImageUrl?: string;
  };
  lastMessage?: {
    sender: string;
    message: string;
    timestamp: string;
  };
  lastMessageAt: string;
  unreadCount?: number;
  mutedBy?: string[];
  pinnedMessages?: string[];
  blockedUsers?: string[];
}

export interface ChatResponse {
  chats: Chat[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalChats: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}

export interface MessagesResponse {
  messages: Message[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalMessages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}

// API functions
export const messageAPI = {
  // Get all chats for the current user (legacy method - now gets active chats)
  getUserChats: async (page = 1, limit = 20): Promise<ChatResponse> => {
    try {
      const response = await axiosInstance.get(`/chats?page=${page}&limit=${limit}&chatStatus=active`);
      return response.data.data;
    } catch (error: any) {
      console.error('Error fetching chats:', error.response?.data || error.message);
      throw error;
    }
  },

  // Get active chats for the current user
  getActiveChats: async (page = 1, limit = 20): Promise<ChatResponse> => {
    try {
      const response = await axiosInstance.get(`/chats?page=${page}&limit=${limit}&chatStatus=active`);
      return response.data.data;
    } catch (error: any) {
      console.error('Error fetching active chats:', error.response?.data || error.message);
      throw error;
    }
  },

  // Create a new chat
  createChat: async (participants: string[], chatType = 'direct', groupName?: string, groupDescription?: string): Promise<Chat> => {
    try {
      const response = await axiosInstance.post('/chats', {
        participants,
        chatType,
        groupName,
        groupDescription
      });
      return response.data.data;
    } catch (error: any) {
      console.error('Error creating chat:', error.response?.data || error.message);
      throw error;
    }
  },

  // Get messages for a specific chat
  getChatMessages: async (chatId: string, page = 1, limit = 50): Promise<MessagesResponse> => {
    try {
      const response = await axiosInstance.get(`/chats/${chatId}/messages?page=${page}&limit=${limit}`);
      return response.data.data;
    } catch (error: any) {
      console.error('Error fetching chat messages:', error.response?.data || error.message);
      throw error;
    }
  },

  // Send a message
  sendMessage: async (chatId: string, message: string, messageType = 'text', replyTo?: string, fileName?: string, fileSize?: number, mediaUrl?: string): Promise<Message> => {
    const payload: any = {
      message,
      messageType,
      replyTo
    };
    
    // Add file metadata if provided
    if (fileName) payload.fileName = fileName;
    if (fileSize) payload.fileSize = fileSize;
    if (mediaUrl) payload.mediaUrl = mediaUrl;
    
    const response = await axiosInstance.post(`/chats/${chatId}/messages`, payload);
    return response.data.data;
  },

  // Upload file using upload-single-media API
  uploadFileToMedia: async (file: File): Promise<{
    secure_url: string;
    resource_type: string;
    format: string;
    bytes: number;
    original_name: string;
    mimetype: string;
  }> => {
    const formData = new FormData();
    formData.append('media', file);
    
    const response = await axiosInstance.post('/media/upload-single', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    
    if (response.data.success && response.data.data) {
      console.log('Media upload successful:', response.data.data.secure_url);
      return {
        secure_url: response.data.data.secure_url,
        resource_type: response.data.data.resource_type,
        format: response.data.data.format,
        bytes: response.data.data.bytes,
        original_name: response.data.data.original_name,
        mimetype: response.data.data.mimetype,
      };
    }
    
    throw new Error('Failed to upload media: ' + (response.data.message || 'Unknown error'));
  },

  // Send a message with media file (upload using upload-single-media API first, then send URL as JSON message)
  sendMessageWithFile: async (chatId: string, file: File, message?: string, messageType?: string, replyTo?: string): Promise<Message> => {
    console.log('Uploading file using upload-single-media API:', {
      fileName: file.name,
      fileType: file.type,
      fileSize: file.size,
    });

    try {
      // Step 1: Upload file using upload-single-media API and get response
      const uploadResponse = await messageAPI.uploadFileToMedia(file);
      console.log('File uploaded successfully:', uploadResponse.secure_url);
      
      // Step 2: Determine message type based on file type and extension
      let finalMessageType = messageType;
      if (!finalMessageType) {
        // Check file extension from original_name as additional safeguard
        const fileExtension = uploadResponse.original_name.split('.').pop()?.toLowerCase();
        
        // Always use the original file.type, not Cloudinary's resource_type
        // because Cloudinary sometimes categorizes PDFs as 'image' resource_type
        if (file.type.startsWith('image/') && !['pdf'].includes(fileExtension || '')) {
          finalMessageType = 'image';
        } else if (file.type.startsWith('video/')) {
          finalMessageType = 'video';
        } else if (file.type.startsWith('audio/')) {
          finalMessageType = 'audio';
        } else if (
          file.type === 'application/pdf' || 
          fileExtension === 'pdf' ||
          file.type.includes('document') ||
          file.type.includes('word') ||
          file.type.includes('excel') ||
          file.type.includes('powerpoint') ||
          file.type === 'text/plain' ||
          file.type === 'text/csv' ||
          ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'csv'].includes(fileExtension || '')
        ) {
          finalMessageType = 'file';
        } else {
          // Everything else is treated as a file (PDFs, documents, etc.)
          finalMessageType = 'file';
        }
        
        console.log('File type detection:', {
          originalFileType: file.type,
          fileExtension,
          cloudinaryResourceType: uploadResponse.resource_type,
          finalMessageType
        });
      }
      
      // Step 3: Send the media URL as a regular JSON message using existing sendMessage function
      const finalMessage = message ? `${message}\n${uploadResponse.secure_url}` : uploadResponse.secure_url;
      
      // Use the existing sendMessage function with JSON format (not form data)
      // Pass file metadata and mediaUrl for proper rendering
      return await messageAPI.sendMessage(
        chatId, 
        finalMessage, 
        finalMessageType, 
        replyTo, 
        uploadResponse.original_name, 
        uploadResponse.bytes,
        uploadResponse.secure_url // Pass the secure_url as mediaUrl
      );
      
    } catch (error) {
      console.error('Failed to upload file or send message:', error);
      throw error;
    }
  },

  // Mark messages as read
  markMessagesRead: async (chatId: string, messageIds?: string[]): Promise<void> => {
    await axiosInstance.patch(`/chats/${chatId}/read`, {
      messageIds
    });
  },

  // Delete a message
  deleteMessage: async (chatId: string, messageId: string): Promise<void> => {
    await axiosInstance.delete(`/chats/${chatId}/messages/${messageId}`);
  },

  // Restore a deleted message
  restoreMessage: async (chatId: string, messageId: string): Promise<Message> => {
    const response = await axiosInstance.patch(`/chats/${chatId}/messages/${messageId}/restore`);
    return response.data.data;
  },

  // Start typing indicator
  startTyping: async (chatId: string): Promise<void> => {
    await axiosInstance.post(`/chats/${chatId}/typing/start`);
  },

  // Stop typing indicator
  stopTyping: async (chatId: string): Promise<void> => {
    await axiosInstance.post(`/chats/${chatId}/typing/stop`);
  },

  // Get online status of users
  getOnlineStatus: async (userIds: string[]): Promise<{ [userId: string]: boolean }> => {
    const response = await axiosInstance.get('/chats/users/online-status', {
      params: { userIds }
    });
    return response.data.data.onlineStatus;
  },

  // Search messages in a chat
  searchMessages: async (chatId: string, query: string, page = 1, limit = 20): Promise<{
    messages: Message[];
    query: string;
    totalResults: number;
    pagination: {
      currentPage: number;
      totalPages: number;
      hasNextPage: boolean;
      hasPrevPage: boolean;
    };
  }> => {
    const response = await axiosInstance.get(`/chats/${chatId}/search?query=${encodeURIComponent(query)}&page=${page}&limit=${limit}`);
    return response.data.data;
  },

  // Get user's following list
  getUserFollowing: async (userId: string): Promise<Array<{
    _id: string;
    username: string;
    fullName: string;
    profileImageUrl?: string;
  }>> => {
    try {
      const response = await axiosInstance.get(`/users/following/${userId}`);
      return response.data.data;
    } catch (error: any) {
      console.error('Error fetching user following:', error.response?.data || error.message);
      throw error;
    }
  },

  // Follow a user
  followUser: async (userId: string): Promise<void> => {
    try {
      await axiosInstance.post('/users/follow', { userId });
    } catch (error: any) {
      console.error('Error following user:', error.response?.data || error.message);
      throw error;
    }
  },

  // Accept message request
  acceptMessageRequest: async (chatId: string): Promise<void> => {
    try {
      await axiosInstance.patch(`/chats/${chatId}/accept`);
    } catch (error: any) {
      console.error('Error accepting message request:', error.response?.data || error.message);
      throw error;
    }
  },

  // Decline message request
  declineMessageRequest: async (chatId: string): Promise<void> => {
    try {
      await axiosInstance.patch(`/chats/${chatId}/decline`);
    } catch (error: any) {
      console.error('Error declining message request:', error.response?.data || error.message);
      throw error;
    }
  },

  // Get message requests
  getMessageRequests: async (page = 1, limit = 20): Promise<ChatResponse> => {
    try {
      const response = await axiosInstance.get(`/chats?page=${page}&limit=${limit}&chatStatus=requested`);
      return response.data.data;
    } catch (error: any) {
      console.error('Error fetching message requests:', error.response?.data || error.message);
      throw error;
    }
  }
};

// Helper function to handle incoming messages and trigger notifications
export const handleIncomingMessage = (message: Message, currentUserId: string) => {
  // Only show notification if the message is not from the current user
  if (message.sender._id !== currentUserId) {
    const senderName = message.sender.fullName || message.sender.username || 'Unknown';
    const notificationData = createMessageNotification(message, senderName);
    
    // Show local notification if the user is currently on the app but not focused on the chat
    // or if the app is in the background
    if (document.hidden || !document.hasFocus()) {
      pushNotificationManager.showLocalNotification(notificationData);
    }
  }
};

// Helper function to setup real-time message listeners (for WebSocket/Socket.IO)
export const setupMessageNotifications = (currentUserId: string) => {
  // This function would typically be called when setting up WebSocket listeners
  // For now, it's a placeholder for the integration point
  console.log('Setting up message notifications for user:', currentUserId);
  
  // You would integrate this with your WebSocket/Socket.IO setup
  // Example:
  // socket.on('newMessage', (message: Message) => {
  //   handleIncomingMessage(message, currentUserId);
  // });
};